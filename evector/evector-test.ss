#lang scheme/base(require (planet schematics/schemeunit:3)         "../vector.ss"         "evector.ss")(define default-fill-value (evector-ref (make-evector 1) 0))(define DFV default-fill-value)(define/provide-test-suite evector-tests  (test-case   "evector"   (check-false (evector? (vector 1 2 3)))   (check-true (evector? (evector 1 2 3)))   (check-true (evector? (evector))))  (test-case   "evector-fill"   (check-equal? (evector-fill (make-evector 10 'foo))  'foo)   (check-equal?    (let ([v (make-evector 10 'foo)])      (set-evector-fill! v 'bar)      (evector-fill v))    'bar))  (test-case   "evector-fill!"   (check-true    (for/and ([l (in-range 100)])             (let ([v (make-evector l)])               (evector-fill! v 'foo)               (equal? (evector->vector v)                       (for/vector ([i l])                                   'foo)))))   (check-true    (for/and ([l (in-range 100)])             (for/and ([i (in-range l)])                      (let ([v (make-evector l 'foo)])                        (evector-fill! v 'bar i)                        (equal? (evector->vector v)                                (for/vector ([j l]) (if (< j i) 'foo 'bar)))))))   (check-equal?    (let ([v (make-evector 20 'foo)])      (evector-fill! v 'bar 10 15)      (evector->vector v))    (for/vector ([i 20])                (if (<= 10 i 14) 'bar 'foo))))  (test-case   "evector-length"   (check-true (for/and ([i (in-range 100)])                        (= (evector-length (make-evector i)) i))))  (test-case   "evector->list"   (check-equal? (evector->list (evector))  (list))   (check-equal? (evector->list (evector 1 2 3))  (list 1 2 3))   (check-true (let ([l (for/list ([i (in-range 100)]) i)])                 (equal? l (evector->list (list->evector l))))))  (test-case   "evector-push!"   (let ([v (for/vector ([i 100]) i)])     (check-equal?      (let ([ev (evector)])        (for ([x (in-vector v)])             (evector-push! ev x))        (evector->vector ev))      v)))  (test-case   "evector-pop!"   (let ([v (for/vector ([i 100]) i)])     (check-equal? (let ([ev (vector->evector v)])                     (for/list ([x (in-vector v)])                               (evector-pop! ev)))                   (reverse (for/list ([x (in-vector v)]) x)))))   (test-case   "evector-ref"   (check-true    (let ([v (evector 0 1 2 3)])      (for/and ([i (in-range 4)])               (= (evector-ref v i) i)))))  (test-case   "evector-set!"   (check-true    (let ([v (evector 0 1 2 3)])      (for/and ([i (in-range 100)])               (begin                 (evector-set! v i 'foo))               (eq? (evector-ref v i) 'foo)))))  (test-case   "evector->vector, vector->evector"   (check-equal? (evector->vector (evector))  (vector))   (check-equal? (evector->vector (evector 1 2 3))  (vector 1 2 3))   (check-true (let ([l (for/vector ([i 100]) i)])                 (equal? l (evector->vector (vector->evector l))))))  (test-case   "make-evector"   (check-equal? (evector->list (make-evector 3))  (list DFV DFV DFV))   (check-equal? (evector->list (make-evector 3 'a))  (list 'a 'a 'a))   (check-equal? (evector-fill (make-evector 10 'foo))  'foo)   (check-equal? (evector->list (make-evector 0 'a #t))  (list))   (check-equal? (evector->list (make-evector 0 'a #f))  (list)))  (test-case   "set-evector-fill"   (check-equal?    (let ([v (make-evector 10 'foo)])      (set-evector-fill! v 'bar)      (evector-fill v))    'bar)   (check-equal?    (let ([v (make-evector 2 'a)])      (set-evector-fill! v 'b)      (set-evector-length! v 1000)      (evector-ref v 999))    'b))  (test-case   "set-evector-length!"   (check-true    (for/and ([i (in-range 11 100)])             (let ([v (make-evector i)])               (set-evector-length! v i)               (and (= (evector-length v) i)                    (eqv? DFV (evector-ref v (- i 1))))))))  (test-case   "evector=?"   (check-true    (and (evector=? (evector 1 2 3) (evector 1 2 3))         (evector=? (evector 1 2 3) (evector 5 4 1)                    (lambda (x y) (= (remainder x 2)                                     (remainder y 2))))         (not (evector=? (evector 1 2 3) (evector 3 2 3)))         (not (evector=? (evector 1 2 3) (evector 1 2 7))))))  (test-case   "evector-map"   (check-equal? (evector->list  (evector-map sqrt (evector 1 4 9 16)))                 '(1 2 3 4))   (check-equal? (evector->list  (evector-map * (evector 1 2 3) (evector 4 5 6 7)))                 '(4 10 18))   (check-equal? (evector->list  (evector-map * (evector 1 2 3 7) (evector 4 5 6)))                 '(4 10 18))   (check-equal? (evector->list  (evector-map + (evector 1 2 3 7) (evector 4 5 6) (evector 7 8)))                 '(12 15)))  (test-case   "evector-for-each"   (check-equal?    (let* ([sum 0] [add (lambda (x) (set! sum (+ sum x)))])      (evector-for-each add (evector 1 2 3))       sum)    6)   (check-equal?    (let* ([sum 0] [add (lambda (x y) (set! sum (+ sum (* x y))))])      (evector-for-each add (evector 1 2 3) (evector 4 5 6))      sum)    (+ (* 1 4) (* 2 5) (* 3 6)))   (check-equal?    (let* ([sum 0] [add (lambda (x y z) (set! sum (+ sum (* x y z))))])      (evector-for-each add (evector 1 2 3) (evector 4 5 6) (evector 7 8 9))      sum)    (+ (* 1 4 7) (* 2 5 8) (* 3 6 9)))   (check-equal?    (let* ([sum 0] [add (lambda (x y z) (set! sum (+ sum (* x y z))))])      (evector-for-each add (evector 1 2 ) (evector 4 5 6) (evector 7 ))      sum)    (+ (* 1 4 7) )))  (test-case   "evector-copy"   (check-true (evector=? (evector 1 2 3) (evector-copy (evector 1 2 3)))))  )